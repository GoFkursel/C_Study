# Day10  “永远把指针指到你要指向的地方”，即*p=&a，否则会有danger！！  
### 一、指针与数组  
数组arr，是数组第一个元素的地址，如果把arr赋给p，两者是一样的   
>printf("%d\n",*p)=printf("%d\n", *arr)= printf("%d\n", arr[0])=printf("%d\n", p[0]) 

***（p+1）= arr[1]**：指针类型变量+1，等同于内存地址+sizeof(int)（这里面的int也不一定非是int，也可能是char）  
**两个指针相减，得到的结果是两个指针的偏移量**：相减再除一个sizeof(int)，相当于得到了元素个数。  
**所有指针类型，相减都是int类型**  
数组作为函数参数会退化为指针，丢失数组的精度，因此在作为函数参数时，会需要将其作为指针（如：bubblesort（int* arr，int len）），并同时传入数组长度  
### 二、指针运算  
>*(p+1)=p[1];//但两个指针相加一定是野指针  
>*(p-1)=p[-1];或者p-arr//虽然负数下标在数组中不能出现，但是对于指针类型就可以  
指针不能相乘或相除，但可以比较，可以逻辑与或  
### 三、指针数组  
int* arr[3]={&a,&b,&c};//指针数组对应于二级指针  
**数组变量指向第一个元素的首地址；  
数组变量指向第一个元素的首地址；  
数组变量指向第一个元素的首地址；**  
arr[0][1]代表了数组a中的第二个元素；//指针数组是一个特殊的二维数组  
arr[i][j]=*(arr[i]+j)= *( *(arr+i)+j)  
### 四、值传递和地址传递  
值传递：形参不影响实参的值；  
地址传递：形参可以影响实参的值；调用时：swap(&a,&b) 写函数时：void swap(int* a,int* b;)//这里的a，b是变量  
### 五、数组作为函数参数  
数组作为函数参数，会退化精度，因此需要用指针来做形参  
调用时：strcat(ch1，ch2)，写函数时：void strcat(char* ch1,char* ch2)    
### 六、指针作为函数返回值  
调用时：char* ch;ch=mystr(ch1,l)；//用来查询某个字符在不在字符串里；写函数时：char* mystr(char* ch1,char l){...return &str[i]...}  
### 七、指针与字符串  
字符串存储数据在栈区；//可以修改  
指针存储数据在数据区常量区字符串；//不可以修改  
> char ch1[]="hello";char ch2[]="world";  
> char* arr[]={ch1,ch2};//这里的字符串中的字符可以修改  
> char* arr[]={"hello","world"};<-字符串数组//这里的字符不可以修改  

### 八、主函数的形参  
int main(int argc,char* arv[])  
int argc:代表传递参数的个数  
char* arv[]：参数列表即：char* arv=[“gcc”，“-o”，...],在运行exe时，输入这些参数，一个空格算一个参数